<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title>Kyle Fung</title>
	<meta name="description" content="I am a wasteman">
	<link href="minimal.css" rel="stylesheet">
</head>
<body>
<div class="container">
	<header>
		<a class="logo" href="http://kylefung.github.io">Kyle Fung</a>
		<nav class="float-right">
			<ul>
                <li>
                <a href="https://kylefung.github.io">Home</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="http://kylefung.github.io/projects.html">Projects</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                <a href="KyleFung.pdf">Resume</a>
                </li>
			</ul>
		</nav>
	</header>

    <h1>Projects</h1>
    <hr>

    <div class="row">
        <h1>WasteTracer</h1>
        <img class="float-left" src="lion256.png" style="width:450px;height:340px;">
        <p>
        This is a GPU accelerated path tracer using Metal compute shaders. You can load OBJ meshes into it and it will generate a path traced image. It supports Blinn-Phong materials (as they seem to be the only material supported by OBJ files) and is accelerated using SAH KD-trees.
        </p>
        <p>
        This image is of a lion model, which has 300k faces and took 1430s to render at 256spp at 800x600.
        </p>
        <p>
        <a href="https://github.com/kylefung/wasteTracer">Code found here</a>
        </p>
    </div>

    <hr>

    <div class="row">
        <h1>Julia</h1>
        <img class="float-left" src="julia.png" style="width:450px;height:340px;">
        <p>
        A small weekend project I made when I had nothing to do. It's a path traced render of a quarternion Julia set, which I think is one of the cooler looking fractals out there. I learned to implement this from this <a href="http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/">blog</a>.
        </p>
        <p>
        It's implemented in a shader on ShaderToy, which is a website that lets you program in a shader language similar to GLSL and have it render in browser.
        </p>
        <p>
        <a href="https://www.shadertoy.com/view/llBfzR">Demo and code found here</a>
        </p>
    </div>

    <hr>

    <div class="row">
        <h1>Jiggle</h1>
        <img class="float-left" src="jiggle.png" style="width:450px;height:340px;">
        <p>
        A 3D simulation of deformable solids using a mass-spring model. I implemented a semi-implicit Euler method (Baraff-Witkin) to solve the dynamics of the springs.
        </p>
        <p>
        This also supports dynamic collision detection, which is sped up with the use of an in-place bounding volume oct-tree. Collision response is still a work in progress, however.
        </p>
        <p>
        Rendering is taken care of using immediate mode OpenGL, which is why the graphics look absolutely terrible.
        </p>
        <p>
        <a href="https://github.com/KyleFung/jiggle">Code found here</a>
        </p>
    </div>

    <hr>

    <div class="row">
        <h1>wasteEngine</h1>
        <img class="float-left" src="wasteEngine.png" style="width:450px;height:340px;">
        <p>
        My first attempt at making a 3D graphics engine. It's written in C++, with the rendering taken care of by OpenGL and windowing with GLUT.
        </p>
        <p>
        Meshes can be loaded as models from OBJ files, with the mesh processing taken care of by ASSIMP. Textures can also be loaded in to texture these models.
        </p>
        <p>
        The image to the left is of a dragon mesh I downloaded from the internet textured with a picture of my friend <a href="http://ernest-wong.me/">Ernest</a>.
        </p>
        <p>
        <a href="https://github.com/KyleFung/wasteEngine">Code found here</a>
        </p>
    </div>

    <hr>

    <div class="row">
        <h1>FluidCanvas</h1>
        <img class="float-left" src="smoke.png" style="width:450px;height:340px;">
        <p>
        This is an implementation of a solution to the <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations#Incompressible_flow">Navier-Stokes</a> equations for incompressible fluids. It also supports vorticity confinement. Most of the theory is explained <a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch38.html">here</a> if you want to build something similar.
        </p>
        <p>
        I wanted it to be interactive through a browser, so I implemented it in Javascript and canvas. Click around <a href="https://rawgit.com/KyleFung/fluidCanvas/smoke/index.html">here</a> to play with it.
        </p>
        <p>
        Free surface tracking is supported using marker cells and particles, but it suffers from pretty bad volume loss.
        </p>
        <p>
        <a href="https://github.com/KyleFung/fluidCanvas">Code found here</a>
        </p>
    </div>

    <hr>

    <div class="row">
        <h1>Ray Tracer</h1>
        <img class="float-left" src="rayTracer.png" style="width:450px;height:340px;">
        <p>
        A CPU based implementation of a recursive ray tracer in C++. It calculates color values using Blinn-Phong lighting. Supports shadows and reflections.
        </p>
        <p>
        Reads in scene files and writes out an image in the ppm format.
        </p>
        <p>
        The image to the left is a rendering of the <a href="https://en.wikipedia.org/wiki/Cornell_box">Cornell Box</a>.
        </p>
        <p>
        <a href="https://github.com/KyleFung/RayTracer">Code found here</a>
        </p>
    </div>


    <hr>

    <div class="row">
        <h1>Voxel Renderer</h1>
        <img class="float-left" src="cubes.png" style="width:450px;height:340px;">
        <p>
        This is a program that generates voxel data, then renders it. The application is written in C++, with the voxel data generation being done in CUDA C and the rendering by OpenGL using CUDA/OpenGL interoperability.
        </p>
        <p>
        This was originally intended to be an implementation of <a href="https://en.wikipedia.org/wiki/Marching_cubes">Marching Cubes</a>, but I had to start school before I could really get it off the ground.
        </p>
        <p>
        The image to the left is a frame shown where the CUDA kernel generating the voxel data generates a checkerboard pattern. Other kernels could be made, but at the moment all this does is render a checkered cube.
        </p>
        <p>
        <a href="https://github.com/KyleFung/smokeBox">Code found here</a>
        </p>
    </div>

	<footer>
			&copy; Kyle Fung 
	</footer><!-- footer -->
</div>
</body>
</html>
